# Общее
Следует покрывать тестами примерно 70-80% строк.
Общая структура: given, when. then.
Unit-тесты - очень маленькие и быстрые, без дополнительных зависимостей.
Интеграционные тесты - медленные, но содержат разные связи, например, БД или же контекст спринга.
Функциональные (End-to-End) тесты - тестирование уже запущенного приложения, например, с помощью Селениума.

TDD - сначала напиши тесты, а потом постепенно крась их в зелёный своим кодом.
BDD - Behavior Driven Development - основывается на TDD и требует описания тестов в терминах желаемого поведения юнита.

Mock - фейковый вариант всего класа, как реализация интерфейса, который наследует класс.
Spy - частичный Mock, переписывает лишь некоторые методы. Редко используется.

Интеграционное тестирование - по конвенции, название классов заканчиваются на IT вместо Test.

Отличие JUnit 5 от JUnit 4.
1) Быстрее, лучше, круче, модульнее.
2) Ожидаемые ошибки и ожидаемый таймаут - теперь в Assertions.
3) Spring запускается с ExtendWith(SpringExtension.class), а не с RunWith(SpringJUnit4ClassRunner.class).

# Библиотеки
Spring Test Scope
JUnit - база и стандарт
Spring Test и Spring Boot Test - для интеграции со спрингом.
AssertJ - для различных утверждений
Hamcrest - упрощает сравнения
Mockito - фреймворк для моков.
JSONassert и JSONPath - для работы с JSON, утверждений и XPath.
Awaitility - для ожидания асинхронных событий (например, ответа от другого микросервиса)

# Аннотации
Аннотации спринга (JUnit 4, могут устареть).
@RunWith(SpringRunner.class) - запуск с контекстом спринга
@SpringBootTest - будет искать Spring Boot Application на тему конфигурации
@TestConfiguration - местная конфигурация
@MockBean и @SpyBean - бины от Mockito
@JsonTest - создаёт Jackson или Gson object wrapper.
@WebMvcTest(controllers = {ControllerToTest.class}) - использует контекст веба, но не создаёт полноценный http сервер. 
@DataJpaTest, @JdbcTest и @DataMongoTest - для тестирования уровня доступа к бд.
@RestClientTest - создаёт mock сервера для тестирования rest клиентов.
@BootStrapWith - указывает, как запускать контекст
@ContextConfiguration и @ContextHierarchy - для настройки контекста для теста.
@ActiveProfiles - для выбора типа профилей.
@TestPropertySource - источники данных.
@DirtiesContext - позволяет перезагружать контекст после теста (долго и дорого)
@WebAppConfiguration - намекает Spring, что стоит использовать контекст веб-приложения.
@TestExecutionListeners - позволяет повесить слушателей на события в тесте.
@Transactional - запускает тест как транзакцию, в конце откатывается
@Commit - говорит, что откатываться таки не надо
@BeforeTransaction и @AfterTransaction - действие перед и после транзакций.

# Москиты Mockito
Использование Mock.
1) Пометить поле со значением, которое надо замочить аннотацией Mock.
2) Написать MockitoAnnotations.initMocks(this).
  2.1) Если надо воткнуть его в соответствующие поля тестируемого объекта - можно просто приписать к этому объекту @InjectMocks. 
3) Написать Mockito.when(объект.метод()).thenReturn(что возвращать).
  3.1) Можно вместо Mockito использовать BDDMockito, что в целом то же самое, но поудобнее вроде.

А ещё можно написать @MockBean и само всё сделается и вставится куда надо (только Spring).

Mockito.verify
Используется, чтобы проверить что-то про Mock - например, что определённый метод был вызван лишь 1 раз.
Mockito.verify(объект, Mockito.times(1)).метод()

ArgumentCaptor
Позволяет перехватывать аргумент, переданный в Mock. 
Полезно, если мы не можем получить доступ к аргументу за пределами метода.

MockMVC - спринговская штука, позволяет тестировать контроллеры.
Создаётся, билдится (для unit подходит standalone builder).
Потом вызывается perform с MockMvcRequestBuilder.get(url), потом andExpect(status().isOk()) или же andExpect(view().name("index")).

WireMock - моки для веб-сервиса. Позволяет сделать HTTP, к которому мы аля сможем приконнектится.