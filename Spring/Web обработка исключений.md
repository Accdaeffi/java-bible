# Зачем вообще?
Чтобы красиво было. Чтобы можно было кидать исключения из мапперов. Чтобы можно было прописывать, что вернут эти исключения, с каким кодом и каким текстом.

# Разные реализации
## @ExceptionHandler(Exception.class)
1. На уровне контроллера.
2. Вешается на отдельный метод, получающий на вход Exception и возвращающий Response.
3. Можно воткнуть сразу несколько исключений в скобочки - но тогда будут проблемы с входными параметрами метода.
4. Для того, чтобы повесить красивый код ответа - надо использовать @ResponseStatus.

В целом - удобно и рабоче, но надо определять в каждом контроллере. Можно конечно похимичить с наследованием, но долго и сложно.

## HandlerExceptionResolver
1. На уровне приложения.
2. Интерфейс для обработки исключений.
3. Можно взять дефолтную реализацию - DefaultHandlerExceptionResolver.
	3.1. Неплохо вешает коды ответы.
	3.2. Вешает только коды - никакого тела.
	3.3. Для настройки, какой код возвращать в случае какого исключения - есть аннотация @ResponseStatus(value = HttpStatus.\*). Вешается на конкретное исключение.
4. Можно написать свою обработку - достаточно лишь создать унаследованый класс от AbstractHandlerExceptionResolver и реализовать doResolveException.	
	4.1. Максимально гибко.
	4.2. Надо проверять, какое исключение возникло и вручную прописывать тело и все статусы.
	
Не самое удобное, не самое гибкое, но для стандартных исключений на всё приложение - почему бы и нет. 

## @ControllerAdvice
1. По дефолту - на уровне приложения, но можно похимичить и будет лишь на определённые контроллеры.
2. Создаётся класс, на него вешается @ControllerAdvice, внутри создаются методы. 
	2.1. На методы вешается @ExceptionHandler(BusinessException.class)
		2.1.1. Можно на один метод повесить несколько исключений - через запятую перечислить.
	2.2. Методы получают на вход эти самые BusinessException
	2.3. Методы возвращают ResponseEntity.
3. Для того, чтобы обрабатывать исключения лишь от определённых контроллеров:
	3.1. Создаётся кастомная аннотация - например, @CustomHandler.
	3.2. Эта аннотация вешается на контроллеры, откуда надо улавливать исключения.
	3.3. Прописывается @ControllerAdvice(annotations = CustomHandler.class), чтобы класс advice мог понять, данные с каких аннотаций ему собирать.
	
Гибко, удобно и вообще круто. Но надо прописывать аннотации и классы, что немного минус.

## ResponseStatusException
1. Специальное исключение, выброс которого приведёт к созданию ответа. 
2. throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "ResponseStatusException in testResponseStatusException");

МАКСИМАЛЬНО просто, хорошоо в простых вариантах, но так себе хоть немного в сложных.

# Просто полезно
Можно включить отображение текста ошибки - server.error.include-message=always

# Список литературы
Обработка исключений в контроллерах Spring: https://habr.com/ru/post/528116/?ysclid=l1152bh5ne