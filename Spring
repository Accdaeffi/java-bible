Dependency Injection
@Qualifier("beanName") - чтобы указать, какой именно брать. Вешается в момент иньекции.
@Profile("test") - указывает, к какому профилю относится бин. Сам профиль меняется в .properties файле как "spring.profile.active=test".
@Primary - чтобы сделать приоритетным для выбора (если есть несколько одинаковых) и другие методы не используются.

Жизненный цикл бина
1) Создание инстанса.
2) Заполнение полей
3) Работа с *Awarness
  3.1) Установка имени бина, если BeanNameAwarness
  3.2) Установка фабрики бинов, если BeanFactoryAwarness
  3.3) Установка контекста, если ApplicationContextAwarness
4) Преинициализация - вызовы @PostConstruct методов в порядке определения в класе. + отработка PreInitialization от BeanPostProcessors
5) Если имплементирован InitializingBean - вызов afterPropertiesSet() метода.
6) Вызов метода, указанного в @Bean(initMethod="foo")
7) Отработка PostInitialization от BeanPostProcessors
8) ЖИВОЙ
9) Контейнер посылает сигнал на завершение.
10) Отработка @PreDestroy методов в порядке определения в классе.
11) Если импелементирован DisposableBean - отработка destroy()
12) Вызов метода, указанного в @Bean(destroyMethod="bar")
13) Смерть.

External Properties
Берутся из аргументов командной строки, переменных окружения и файлов с параметрами. Возможна перезапись в порядке написания (т.е. аргументы командной строки - самое важное).
Spring сам берёт значения из application.properties в ресурсах, но можно указать дополнительные файлы с аннотацией @PropertySource("classpath:foo.properties").

Если есть значение foo.bar, то задача его значения будет выглядеть так:
properties: foo.bar=test
env var: FOO_BAR=test
CL args: --foo.bar=test
Да, они все переписывают одно и то же значение.

properties файлы дополнительно могут переписывать друг друга - например, про использовании профилей. Также они могут автоматически подключаться при смене профиля.
Так, например, про использовании профиля "dev" кроме application.properties будет автоматически подключен ещё application-dev.properties.

Если все значения в одном файле имеют одинаковый префикс (например, db.foo, db.bar...), можно использовать аннотацию @ConfigurationProperties("db"), чтобы не писать каждый раз. 
Правда, это также потребует наличия @Configuration.

Тестирование
Следует покрывать тестами примерно 70-80% строк.
Unit-тесты - очень маленькие и быстрые, без дополнительных зависимостей.
Интеграционные тесты - медленные, но содержат разные связи, например, БД или же контекст спринга.
Функциональные (End-to-End) тесты - тестирование уже запущенного приложения, например, с помощью Селениума.

TDD - сначала напиши тесты, а потом постепенно крась их в зелёный своим кодом.
BDD - Behavior Driven Development - основывается на TDD и требует описания тестов в терминах желаемого поведения юнита.

Mock - фейковый вариант всего класа, как реализация интерфейса, который наследует класс.
Spy - частичный Mock, переписывает лишь некоторые методы. Редко используется.

Spring Test Scope
JUnit - база и стандарт
Spring Test и Spring Boot Test - для интеграции со спрингом.
AssertJ - для различных утверждений
Hamcrest - упрощает сравнения
Mockito - фреймворк для моков.
JSONassert и JSONPath - для работы с JSON, утверждений и XPath.

Аннотации спринга (JUnit 4, могут устареть).
@RunWith(SpringRunner.class) - запуск с контекстом спринга
@SpringBootTest - будет искать Spring Boot Application на тему конфигурации
@TestConfiguration - местная конфигурация
@MockBean и @SpyBean - бины от Mockito
@JsonTest - создаёт Jackson или Gson object wrapper.
@WebMvcTest - использует контекст веба, но не создаёт полноценный http сервер.
@DataJpaTest, @JdbcTest и @DataMongoTest - для тестирования уровня доступа к бд.
@RestClientTest - создаёт mock сервера для тестирования rest клиентов.
@BootStrapWith - указывает, как запускать контекст
@ContextConfiguration и @ContextHierarchy - для настройки контекста для теста.
@ActiveProfiles - для выбора типа профилей.
@TestPropertySource - источники данных.
@DirtiesContext - позволяет перезагружать контекст после теста (долго и дорого)
@WebAppConfiguration - намекает Spring, что стоит использовать контекст веб-приложения.
@TestExecutionListeners - позволяет повесить слушателей на события в тесте.
@Transactional - запускает тест как транзакцию, в конце откатывается
@Commit - говорит, что откатываться таки не надо
@BeforeTransaction и @AfterTransaction - действие перед и после транзакций.

