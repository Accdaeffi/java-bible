Dependency Injection
@Qualifier("beanName") - чтобы указать, какой именно брать. Вешается в момент иньекции.
@Profile("test") - указывает, к какому профилю относится бин. Сам профиль меняется в .properties файле как "spring.profile.active=test".
@Primary - чтобы сделать приоритетным для выбора (если есть несколько одинаковых) и другие методы не используются.

Жизненный цикл бина
1) Создание инстанса.
2) Заполнение полей
3) Работа с *Awarness
  3.1) Установка имени бина, если BeanNameAwarness
  3.2) Установка фабрики бинов, если BeanFactoryAwarness
  3.3) Установка контекста, если ApplicationContextAwarness
4) Преинициализация - вызовы @PostConstruct методов в порядке определения в класе. + отработка PreInitialization от BeanPostProcessors
5) Если имплементирован InitializingBean - вызов afterPropertiesSet() метода.
6) Вызов метода, указанного в @Bean(initMethod="foo")
7) Отработка PostInitialization от BeanPostProcessors
8) ЖИВОЙ
9) Контейнер посылает сигнал на завершение.
10) Отработка @PreDestroy методов в порядке определения в классе.
11) Если импелементирован DisposableBean - отработка destroy()
12) Вызов метода, указанного в @Bean(destroyMethod="bar")
13) Смерть.

External Properties
Берутся из аргументов командной строки, переменных окружения и файлов с параметрами. Возможна перезапись в порядке написания (т.е. аргументы командной строки - самое важное).
Spring сам берёт значения из application.properties в ресурсах, но можно указать дополнительные файлы с аннотацией @PropertySource("classpath:foo.properties").

Если есть значение foo.bar, то задача его значения будет выглядеть так:
properties: foo.bar=test
env var: FOO_BAR=test
CL args: --foo.bar=test
Да, они все переписывают одно и то же значение.

properties файлы дополнительно могут переписывать друг друга - например, про использовании профилей. Также они могут автоматически подключаться при смене профиля.
Так, например, про использовании профиля "dev" кроме application.properties будет автоматически подключен ещё application-dev.properties.

Если все значения в одном файле имеют одинаковый префикс (например, db.foo, db.bar...), можно использовать аннотацию @ConfigurationProperties("db"), чтобы не писать каждый раз. 
Правда, это также потребует наличия @Configuration.



Web MVC
Если надо вернуть не просто строку, а нормальную HTML-страницу, то в сигнатуре метод должен возвращать Model или же ModelAndView.

WebDataBinder - позволяет более гибко настраивать, как привязывать объект к View, например, запрещает работать с некоторыми полями.
Аннотация на метод - @InitBinder, в параметрах - WebDataBinder

Аннотация @ModelAttribute("foo") вешается на метод и позволяет указать, что записывать в атрибут каждого отправленной из контролера модели.
Также можно вешать на поля - и это позволит напрямую

Создание API: аннотация @ResponseBody означает, что объект, возвращаемый методом, надо как-то засунуть в тело ответа. 
Для строки очевидно, а вот разные объекты могут во что-то переделаться - например, в JSON.

Интерфейс Formatter<Class> позволяет удобно парсить строку, вернутую запросом, в объект - например, искать значение в Enum. 
Имплементируется, прописывается нужный класс и метод parse перегружается.

Обработка исключений:
@ExceptionHandler позволяет обрабатывать исключения на уровне контролёра. Более гибко, может работать с ModelAndView (но не с Model).

@ResponseStatus вешается на кастомное исключение и позволяет сказать Spring, какой HTTP код кидать, если это исключение вылезло.
Глобальное для приложения.

SimpleMappingExceptionResolver - позволяет при указанных исключениях перенаправлять на указанный вид. 
Данные передать нельзя, но сказать, что "всё сломалось, но мы работаем", можно.

Дефолтный просто переводит стандартные исключения Spring в коды - но ничего более.

Можно сделать своё - и даже указать приоритетность обработки. Для этого надо имплементировать HandlerExceptionResolver.
Желательно, через интерфейс Ordered, указать приоритетность.

Аннотация @ControllerAdvice позволяет отметить класс, где будут глобальные @ExcepptionHandler. 
При тестировании через MockMVC, правда, его надо указывать напрямую - через .setControllerAdvice. 



WebFlux
Альтернатива WebMVC для упора в реактивность. Работает на Netty контейнере, вместо сервлетов - потоки.
Все сервлеты не работают, WebMVC - тоже. Контроллеры, кстати, вроде пашут.

ModelAndView не работает, а вот Model - спокойно.

Для валидации - тот же самый @Valid, только выглядит вот так
public Mono<String> saveOrUpdate(@Valid @ModelAttribute("recipe") Mono<RecipeCommand> command) {
    return command
        // нормальное поведение
        .flatMap(recipeService::saveRecipeCommand)
        .map(recipe -> "redirect:/recipe/" + recipe.getId() + "/show")
        // вылезает при ошибке 
        .doOnError(thr -> log.error("Error saving recipe"))
        .onErrorResume(WebExchangeBindException.class, thr -> Mono.just(RECIPE_RECIPEFORM));
}

RouterFunction позволяет отдельно настроить, что возвращают некоторые запросы. Оформляется как @Bean в классе конфигов.
(хз вообще, зачем, но ладно) Полезно для создания api.

WebTestClient можно использовать для тестирования.
Забиваются все параметры, потом .exchange() для осуществления запроса и куча .expect*() для проверки.



i18n 
По-дефолту - берутся из Accpet-language пришедшего заголовка HTTP. 
Но, если сильно надо, можно использоваться FixedLocaleResolver (берёт из настроек JVM), а также CookieLocaleResolver (из печенек) или SessionLocaleResolver (из парамтеров сессии).

Файлы локализации берутся в порядке - полное совпадение, только язык, какое-то дефолтное (без указания локализации).
