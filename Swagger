Фреймворк для создания качественного (понятного и людям, и компьютерам) интерфейса для REST API, позволяющего понять, как и куда стучаться и что может прилететь в ответ без копания в документации и исходниках.

У REST нет стандарта (спецификации) - и Swagger её задаёт.
JSON для метадаты
JSON для задания API
JSON для схемы спецификации модели

Работает не только на Java.

Состоит из:
Swagger UI - для автогенерации документации из Swagger Complaint API
Swagger Editor - для ручной модификации API
Swagger Codegen - генерирует код из документации

Спецификация пишется на JSON или YAML. Но типы данных, описание объектов - из JSON.

Для активации Swagger 2 (сейчас актуальна версия 3.1):
@EnableSwagger2 на класс с конфигом

Настройка - через бин, который возвращает Docket. 
В конце можно приделать .apiInfo(metadata()), где metadata - метод, возвращающий метадату о самом API (класс - ApiInfo).

Если как-то делать не через спринг, чтобы был нормальный swagger-ui, надо:
1) Перезапискать addResourceHandler (унаследовав от WebMvcConfigurationSupport).
2) Добавить туда в ResourceHandlerRegistry (входной параметр):
  1. "swagger-ui.html" с локациями в "classpath:/META-INF/resources/"
  2. "/webjars/**" с локациями в "classpath:/META-INF/resources/webjars/"
  
Для более кастомного описания можно вешать следующие аннотации:
@Api(desription = "foo") - на контроллер.
@ApiOperation(МНОГА) - на каждый метод.
@ApiResponse() - на каждый метод, чтобы описать, с каким кодом какой тип данных возвращает. Или несколько - тогда @ApiResponses(value = {@ApiResponse()}).
@ApiModelProperty(value = "descr", required = true) - на поле возвращаемого класса, required - позволяет понять, что значение таки надо посылать.
