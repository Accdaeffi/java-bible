API, позволяющее отправку сообщений в другие приложения - обычно Java, но не всегда.
Как JPA - спецификация и требует реализации, например, Apache Active MQ, RabbitMQ или JBoss Messaging.

Асинхронно, быстро, гибко (можно одному, а можно броадкаст), безопасно, надёжно.

Типы сообщений:
Point to Point - лишь один получатель. Работает через очередь. Может быть несколько консумеров, но придёт лишь раз.
Publish/Subscribe - отправляется всем, кто подписан на определённый топик. 

Сообщение содержит:
Header - метаданные о сообщении
Properties - в 3 секциях:
  Application - от приложения
  Provider - от провайдера (специфичны)
  Standart Properties - (могут вообще не поддерживаться)
Payload - само сообщение

Некоторые параметры из Header:
JMSCorrelationID - строчка, UUID, позволяет проследить сообщение через множество потребителей.
JMSExpires - Long, как долго будет жить. Если 0 - будет жить вечно.
JMSMessageID - строчка, ставится провайдером
JMSPriority - Integer, приоритет
JMSTimestamp - Long, когда было послано
JMSType - строчка, тип сообщения
JMSReplyTo - queue или топик, на который отправитель ожидает ответы
JMSRedelivery - было ли перенаправлено?
JMSDevileryMode - Integer, ставится провайдером.
  Persistent (дефолтный) - гарантировать доставку.
  Non-persistent - потери это норма.
  
Параметры из Properties:
Провайдера:
  JMSXUserID - String - id пользователя, пославшего сообщение
  JMSXAppID - String - id приложения, отправляющего сообщение
  JMSXDeliveryCount - Integer - количество попыток доставки
  JMSXConsumerTXID - String - id транзакции, в рамках которой сообщение было получено
  JMSXRcvTimestamp - Long - когда именно сообщение было получено
  JMSXState - Integer - состояние сообщения
Клиента:
  JMSXGroupID - String - к какой группе принадлежит сообщение
  JMSXGroupSeq - Integer - номер сообщения в группе
Продюсера:  
  JMSXProducerTXID - String - id транзакции, в рамках которой было создано сообщение
  
Кастомные параметры - ставятся String/что-то.

Типы сообщений:
Message - пустое, просто сообщить о событии
BytesMessage - массив байтов
TextMessage - содержит строку (можно JSON или XML) - лучше всего использовать это
StreamMessage - последовательность примитивов
MapMessage - содержит нечто аля Map
ObjectMessage - сериализированный объект

Для класса сообщений надо имплементировать Serializable и, желательно, указать serialVersionUID.

Настройка сервака - лучше по гайду из документации.


Отправляется через JmsTemplate - билдится, настраивается, сендится.
Также необходимо настроить название очереди/топика.

Получается через @JmsListener(destination = "название очереди/топика") на метод.
В методе должен быть @Payload для класса-содержания, @Headers для MessageHeaders ну и/или сам Message, если надо целиком.

Отправка и ожидание ответа - надо sendAndRecieve, внутрь передать очередь/топик и имплементацию MessageCreator, где реализован метод createMessage(Session foo).
В рамках этой реализации создаётся объект Message - например, через session.createTextMessage и он же возвращается.
Для того, чтобы передавать сериализованный класс, надо ещё установить тип, а позднее его считать.

Для получения и отправки ответа -  стандартный Listener, в котором стандартный jmsTemplate.convertAndSend(incomingMessage.getJMSReplyTo(), payloadMessage).


Для того, чтобы сообщения нормально парсились - надо сделать бин MessageConverter.
Пример: MappingJackson2MessageConverter, устанавливаем targetType(MessageType.Text) и откуда брать исходный класс (setTypeIdPropertyName("_type")). 
Позднее (например, в реализации для sendAndRecieve) надо не забывать устанавливать туда полный путь до файла. 

Для того, чтобы асинхронно в спринге отправлять сообщения - надо настроить бин интерфейса TaskExecutor, возвращая SimpleAsyncTaskExecutor.
На класс конфига при этом надо повесить @EnableScheduling и @EnableAsync. 
Также на сам метод, который будет асинхронно выполняться, надо повесить @Scheduled()

У спринга есть своя реализация Message, которая абстракция и сойдёт - удобнее переходить с одного брокера сообщений на другой (например, на Кафку).

Для подключения к внешнему серваку (например, artemis):
spring.artemis.user=
spring.artemis.password=
